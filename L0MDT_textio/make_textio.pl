#!/usr/bin/perl
#------------------------------------------------------------
# read VHDL type definitions from 
# generate textio package with READ and WRITE functions for each
# Mods:
# 2020-04-22, hazen:  Switch to hex I/O.  This requires rounding
#   up temporary vectors to multiple of 4 length and using
#   HREAD/HWRITE
#------------------------------------------------------------

use strict;
use lib '.';
use ReadTypes;
use Data::Dumper;

my $debug = 1;

my $na = $#ARGV+1;
die "usage: $0 l0mdt_buses_types.vhd l0mdt_buses_textio.vhd" if( $na < 1);

my $f_input = $ARGV[0];
my $f_output = $ARGV[1];
my $yes = lc( $ARGV[2]) eq "y";

# check for over-write
if ( -e $f_output) {
    print qq{File $f_output exists.  I'm about to over-write it
with the textio library.  Is this OK (y/n)?};
    if( !$yes) {
	my $yesno = <STDIN>;
	die "Aborted" if( $yesno !~ /^[yY]/);
    }
}

open VHI, "< $f_input" or die "Opening $f_input: $!";
open VHO, "> $f_output" or die "Opening $f_output: $!";

# use external module to read and process the VHDL types
my $types = ReadTypes( CleanHDL(\*VHI));

if( $ReadTypes::errors) {
    print "Errors reading input files:\n$ReadTypes::errors";
    exit;
}

print "$ReadTypes::ntypes user types found\n";

my $type;

#------------------------------------------------------------
# output the preamble
#------------------------------------------------------------

print VHO qq{
----------------------------------------------------------------------
-- Automatically generated by 'make_textio.pl' from $f_input
----------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_textio.all;
use std.textio.all;

library l0mdt_lib;
use l0mdt_lib.mdttp_constants_pkg.all;
use l0mdt_lib.mdttp_types_pkg.all;

package mdttp_textio is

};

#
# first pass, output the procedure declarations
#
foreach $type ( @{$types->{"NAMELIST"}}) {
  # ignore / flag array types for now
    print "PASS1: $type\n" if($debug);
##    if( lc($types->{$type}->{"CLASS"}) eq "array") {
##	print "Ignoring array type $type for now\n";
##	print "DUMP: ", Dumper( $types->{$type}) if( $debug);
##    } else {
	print VHO qq{
  procedure READ(L:inout LINE; VALUE:out $type);
  procedure WRITE(L:inout LINE; VALUE:in $type);
	};
#    }
}

#
# intermediate stuff
#
print VHO qq{
end mdttp_textio;

package body mdttp_textio is

  -- round up vector length to multiple of 4
  function len4r(len : integer) return integer is
  begin
    return len + (3-((len-1) mod 4));
  end len4r;

};


foreach $type ( @{$types->{"NAMELIST"}}) {

    print "PASS2: $type\n" if($debug);

##    if( lc($types->{$type}->{"CLASS"}) eq "array") {
##	print " (array: skipped)\n" if( $debug);
##    } else {
##	print "\n" if( $debug);
##    }
    

    my $class = lc($types->{$type}->{"CLASS"});

    # shortcut to name list
    my ($namelist, $nnames, $lastvar);
    if( $class eq "array") {
	$namelist = $types->{$type}->{"NAMELIST"};
	$nnames = $#{$namelist};   	# number of names
	$lastvar = $namelist->[$nnames]; # name of last item
    }

    #------------------------------------------------------------
    # generate the READ procedure
    #------------------------------------------------------------
    print VHO qq{
  procedure READ(L:inout LINE; VALUE:out $type) is
};

    # now generate variables of the actual types
    # SLV need special treatment to round up length
    print VHO "\n";

    if( $class eq "record") {
	foreach my $var ( @{$namelist}) {
	    my $typ = $types->{$type}->{$var}->{"type"};
	    my $siz = $types->{$type}->{$var}->{"size"};
	    if( $typ =~ /std_logic_vector/) {
		$typ = "std_logic_vector(len4r($siz)-1 downto 0)";
	    }
	    print VHO qq{    variable v_$var : $typ;\n};
	}
    } elsif( $class eq "array") {
	# generate an integer for the array index
	print VHO qq{    variable v_index : integer;\n};
	print VHO qq{    variable v_data : $type;\n};
    } else {
	print "Unknown CLASS = $class\n";
    }


    print VHO "\n\n  begin\n\n";

    # generate the READ or HREAD calls
    if( $class eq "record") {
	foreach my $var ( @{$namelist}) {
	    my $typ = $types->{$type}->{$var}->{"type"};
	    my $user = $types->{$type}->{$var}->{"user"};
	    # SLV get HREAD call, others just READ
	    if( $typ =~ /std_logic_vector/) {
		print VHO "    HREAD(L, v_$var);\n";
	    } else {
		print VHO "    READ(L, v_$var);\n";
	    }
	}    
    } elsif( $class eq "array") {
	print VHO "    READ(L, v_index);\n";   # read index
	print VHO "    READ(L, v_data(v_index));\n";
    }


    print VHO "\n";

    # now build the return value, taking care
    # to use the correct size for SLV
    print VHO "    VALUE := (\n";
    foreach my $var ( @{$namelist}) {
	my $typ = $types->{$type}->{$var}->{"type"};
	my $user = $types->{$type}->{$var}->{"user"};
	my $siz = $types->{$type}->{$var}->{"size"};
	if( $typ =~ /std_logic_vector/) {
	    print VHO "        $var => v_$var($siz-1 downto 0)";	    
	} else {
	    print VHO "        $var => v_$var";
	}
	if( $var ne $lastvar) {
	    print VHO ",\n";
	} else {
	    print VHO ");\n";
	}
    }    

    print VHO "  end READ;\n\n\n";




    #------------------------------------------------------------
    # generate the WRITE procedure
    #------------------------------------------------------------
    print VHO qq{
  procedure WRITE(L:inout LINE; VALUE:in $type) is
};

    # now generate variables of the actual types
    # SLV need special treatment to round up length
    print VHO "\n";
    foreach my $var ( @{$namelist}) {
	my $typ = $types->{$type}->{$var}->{"type"};
	my $siz = $types->{$type}->{$var}->{"size"};
	if( $typ =~ /std_logic_vector/) {
	    $typ = "std_logic_vector(len4r($siz)-1 downto 0)";
	}
	print VHO qq{    variable v_$var : $typ;\n};
    }
    print VHO "\n    variable v_SPACE : character;\n\n  begin\n\n";
    
    # extract values from input record
    foreach my $var ( @{$namelist}) {
	my $typ = $types->{$type}->{$var}->{"type"};
	my $user = $types->{$type}->{$var}->{"user"};
	my $siz = $types->{$type}->{$var}->{"size"};
	# SLV need special treatment
	# the temporary vector may be longer, so zero it first to be safe
	if( $typ =~ /std_logic_vector/) {
	    print VHO "    v_$var := (others => '0');\n";
	    print VHO "    v_$var($siz-1 downto 0) := VALUE.$var;\n";
	} else {
	    print VHO "    v_$var := VALUE.$var;\n";
	}
    }

    # generate the WRITEs
    foreach my $var ( @{$namelist}) {
	my $typ = $types->{$type}->{$var}->{"type"};
	my $user = $types->{$type}->{$var}->{"user"};
	my $siz = $types->{$type}->{$var}->{"size"};
	if( $typ =~ /std_logic_vector/) { # SLV, use HWRITE
	    print VHO qq{    HWRITE(L, v_$var);\n};
	} else {		# others just use WRITE
            print VHO qq{    WRITE(L, v_$var);\n};
	}
	if( $var ne $lastvar) {
	    print VHO "    WRITE(L, ' ');\n";
	}
    }

    print VHO "  end WRITE;\n\n";
}


print VHO "end mdttp_textio;\n";
